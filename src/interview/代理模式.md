# 代理模式

由于种种原因，一个对象**不能直接访问**另一个对象，需要一个**第三者**（代理）从而间接达到访问目的。

🌰

- 科学上网
- 事件委托
- ...

```typescript
// 不使用代理模式下需要循环监听函数，性能开销会大
const aNodes = document
  .getElementsByClassName("father")[0]
  .getElementsByTagName("a");
const length = aNodes.length;

for (let index = 0; index < length; index++) {
  aNodes[index].addEventListener("click", (e) => {
    e.preventDefault();
    console.log(`${aNodes[index].innerText}`);
  });
}
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div class="father">
      <a href="#">##1##</a>
      <a href="#">##2##</a>
      <a href="#">##3##</a>
      <a href="#">##4##</a>
      <a href="#">##5##</a>
      <a href="#">##6##</a>
    </div>
    <script src="./dist/test.js"></script>
  </body>
</html>
```

### 事件代理

使用事件代理模式，将事件代理到父元素上，通过父元素对事件进行处理和分发，间接作用于子元素。

```typescript
const fatherNodes = document.getElementsByClassName("father")[0];

fatherNodes.addEventListener("click", (e) => {
  if ((e?.target as HTMLElement).tagName === "A") {
    e.preventDefault();
    console.log(`${(e?.target as HTMLElement).innerText}`);
  }
});
```

### 虚拟代理

#### 图片预加载

先让 img 标签展示一个占位图，然后创建一个 image 实例，让这个 image 的实例的 src 指向真实的图片地址，观察该 image 实例的加载情况，当其对应的真实图片加载完成后，即有了真实图片的缓存，再将 DOM 上的 img 元素的 src 指向真实的目标图片地址。这个时候去取真实图片的缓存，保证了用户的体验。

第一版本

```typescript
class PreLoadImg {
  // 占位图 url 地址
  static LOADING_IMG = "https://cdn2.thecatapi.com/images/8kq.gif";
  imgNode: HTMLImageElement;

  constructor(imgNode: HTMLImageElement) {
    this.imgNode = imgNode;
  }

  // 设置真实的图片地址
  setSrc(targetUrl: string) {
    // img 节点初始化时候展示一个占位图
    this.imgNode.src = PreLoadImg.LOADING_IMG;
    // 创建一个帮助加载的 Image 实例
    const image = new Image();
    // 监听目标图片的加载情况，完成式再将 img 节点的 src 属性设置为目标图片的 url
    image.onload = () => {
      this.imgNode.src = targetUrl;
    };
    // 设置 src 属性，Image 实例开始加载图片
    image.src = targetUrl;
  }
}

const imgNode = document.getElementsByTagName("img")[0];
const preLoadImg = new PreLoadImg(imgNode);

preLoadImg.setSrc("https://cdn2.thecatapi.com/images/ced.jpg");
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    .test-img {
      width: 200px;
      height: 200px;
    }
  </style>
  <body>
    <div class="father">
      <img class="test-img" src="" alt="" />
    </div>
    <script src="./dist/test.js"></script>
  </body>
</html>
```

上述代码违反了设计原则的**单一职责原则**。 PreLoadImg 不经负责图片的加载，还要负责 DOM 层面的操作，这就出现了**两个可能导致这个类发生变化的原因**。

所以要将两个逻辑分离，PreLoadImage 专心去做 DOM 层面的事情，再设置一个对象来做加载。然后使用代理器帮两个对象关联起来。

第二版本

```typescript
class PreLoadImg {
  // 真实的 dom 节点
  imgNode: HTMLImageElement;

  constructor(imgNode: HTMLImageElement) {
    this.imgNode = imgNode;
  }

  // 设置真实的图片地址
  setSrc(targetUrl: string) {
    this.imgNode.src = targetUrl;
  }
}

class ProxyImg {
  // 占位图 url 地址
  static LOADING_IMG = "https://cdn2.thecatapi.com/images/8kq.gif";
  // 目标Image，即PreLoadImage实例
  targetImg: PreLoadImg;

  constructor(targetImg: PreLoadImg) {
    this.targetImg = targetImg;
  }

  setSrc(targetUrl: string) {
    // 真实img节点初始化时展示的是一个占位图
    this.targetImg.setSrc(ProxyImg.LOADING_IMG);
    // 创建一个帮助加载的 Image 实例
    const vImage = new Image();
    // 监听目标图片的加载情况，完成式再将 img 节点的 src 属性设置为目标图片的 url
    vImage.onload = () => {
      this.targetImg.setSrc(targetUrl);
    };
    // 设置 src 属性，Image 实例开始加载图片
    vImage.src = targetUrl;
  }
}

const imgNode = document.getElementsByTagName("img")[0];
const preLoadImg = new PreLoadImg(imgNode);
const proxyImg = new ProxyImg(preLoadImg);

proxyImg.setSrc("https://cdn2.thecatapi.com/images/ced.jpg");
```

ProxyImg 做了预加载的工作，通过 ProxyImg 这个代理，实现对真实 img 节点的间接访问，实现相应的效果。

vImage 代替真实 DOM 发起图片的请求，和完成图片的加载，但是却从未出现在渲染层，因此这种模式被称为**虚拟代理**

### 缓存代理
