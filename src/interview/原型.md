# 原型

> 来自[mqyqingfeng](https://github.com/mqyqingfeng/Blog/issues/2)

## 构造函数

```javascript
// 构造函数的首字母要大写 用于区分构造函数和普通函数
function Person {

}
let person1 = new Person()
person1.name = 'name1'

console.log(person1.name); // name1
```

### 特点

- 没有显示显示地创建对象
- 属性和方法都赋值给了 this
- 没有 return

## Prototype

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。
实际上，这个对象就是通过调用构造函数创建的**实例对象**的原型。
使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。

```javascript
function Person {

}
Person.prototype.name = 'person'

let person1 = new Person()
let person2 = new Person()

console.log(person1.name); // person
console.log(person2.name); // person
```

<img src="https://eos-wuxi-1.cmecloud.cn/crmoss/552061b3-b9a1-458a-8c31-ec8d9dd9b9b6.png">

## \_\_proto\_\_

在 Firefox、Safari 和 Chrome 会在每个对象(除了 null )上暴露 \_\_proto\_\_ 属性，通过这个属性可以访问对象的原型。

```javascript
function Person {

}

let person1 = new Person()

console.log(person1.__proto__ === Person.prototype); // true
```

<img src="https://eos-wuxi-1.cmecloud.cn/crmoss/de26fa66-7470-418a-b48b-4de3d39e6a8f.png">

## constructor

默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。

```javascript
function Person {

}

let person1 = new Person()
console.log(Person.prototype.constructor === Person); // true
```

<img src="https://eos-wuxi-1.cmecloud.cn/crmoss/464721cf-3dfb-4544-89c4-87b42f8b0e9b.png">

综上可得

```javascript
function Person {

}

let person1 = new Person()
console.log(person1.__proto__ === Person.prototype) // true
console.log(Person.prototype.constructor === Person); // true
console.log(Object.getPrototypeOf(person1) === Person.prototype) // true
```

## 实例与原型

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

```javascript
function Person {

}
Person.prototype.name = '11'

let person1 = new Person()
person1.name = '22'

console.log(person1.name); // 22

delete person1.name

console.log(person1.name); // 11
```

当读取 person .name, 从 person 对象中找不到 name 属性就会去 person 的原型也就是 person.\_\_proto\_\_，也就是 Person.prototype 中寻找。
那如果没找到呢？？？

## 原型的原型

原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 \_\_proto\_\_ 指向构造函数的。

```javascript
let obj = new Object();
obj.name = "nnn";

console.log(obj.name); // nnn
```

<img src="https://eos-wuxi-1.cmecloud.cn/crmoss/1fef9dda-ef80-41c1-b1b7-7a31edebf7d0.png">

## 原型链

```javascript
console.log(Object.prototype.__proto__ === null);
```

当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就会去它的 \_\_proto\_\_ 属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的 \_\_proto\_\_ 属性所指向的父类的父类上去查找。以此类推，直到找到 null

<img src="https://eos-wuxi-1.cmecloud.cn/crmoss/a41b983b-95bf-4a35-b2a9-f2298055538e.png">
