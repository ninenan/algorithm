# 手写实现

## new

1. 创建一个空对象
2. 为创建的空对象添加\_\_proto\_\_属性，并将其链接至构造函数的 prototype
3. 为创建的对象作为 this 的上下文
4. 如果函数没有返回对象，则返回 this

```javascript
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}
```

```javascript
// demo.js
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}

function Person(name, sex) {
  this.name = name;
  return {
    sex: sex,
    height: 178,
  };
}

let person1 = new Person("zhangsan", true);

console.log(person1.name); // undefined
console.log(person1.sex); // true
console.log(person1.height); // 178

let person2 = myNew(Person, "zhangsan", true);
console.log(person2.name); // undefined
console.log(person2.sex); // true
console.log(person2.height); // 178
```

## instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```javascript
function myInstanceof(paramL, paramR) {
  let L = paramL.__proto__;
  let R = paramR.prototype;

  while (true) {
    if (!L) {
      return false;
    }
    if (L === R) {
      return true;
    }
    L = L.__proto__;
  }
}
```

```javascript
// demo.js
function Foo() {}

console.log(myInstanceof(Object, Object)); // true
console.log(myInstanceof(Function, Function)); // true
console.log(myInstanceof(Foo, Foo)); // false
```
