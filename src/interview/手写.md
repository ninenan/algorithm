# 手写实现

## new

1. 创建一个空对象
2. 为创建的空对象添加\_\_proto\_\_属性，并将其链接至构造函数的 prototype
3. 为创建的对象作为 this 的上下文
4. 如果函数没有返回对象，则返回 this

```javascript
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}
```

```javascript
// demo.js
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}

function Person(name, sex) {
  this.name = name;
  return {
    sex: sex,
    height: 178,
  };
}

let person1 = new Person("zhangsan", true);

console.log(person1.name); // undefined
console.log(person1.sex); // true
console.log(person1.height); // 178

let person2 = myNew(Person, "zhangsan", true);
console.log(person2.name); // undefined
console.log(person2.sex); // true
console.log(person2.height); // 178
```

## instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```javascript
function myInstanceof(paramL, paramR) {
  let L = paramL.__proto__;
  let R = paramR.prototype;

  while (true) {
    if (!L) {
      return false;
    }
    if (L === R) {
      return true;
    }
    L = L.__proto__;
  }
}

// demo
function Foo() {}

console.log(myInstanceof(Object, Object)); // true
console.log(myInstanceof(Function, Function)); // true
console.log(myInstanceof(Foo, Foo)); // false
```

## call

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
// 传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替
// context 不传就默认是 window 环境
Function.prototype.myCall = function (context = window, ...rest) {
  rest = rest ? rest : [];
  // 给 context 新增一个独一无二的属性防止覆盖原有的属性
  const key = Symbol();
  // 获取调用call的函数，用this可以获取
  context[key] = this;
  // 通过隐式绑定的方式调用函数
  const result = context[key](...rest);
  // 删除添加的属性
  delete context[key];
  // 返回函数调用的返回值
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.call(obj, false, "catXXX"); // xxx 25 false catXXX
foo.myCall(obj, false, "catXXX"); // xxx 25 false catXXX

console.log(Math.max.call(Math, 1, 2, 3, 4, 1, 10)); // 10
console.log(Math.max.myCall(Math, 1, 2, 3, 4, 1, 10)); // 10

console.log([].shift.call([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myCall([1, 2, 3, 4, 5, 6])); // 1
```

## apply

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
Function.prototype.myApply = function (context = window, ...reset: any[]) {
  reset = reset[0] ? reset[0] : [];
  // 给context新增一个独一无二的属性以免覆盖原有属性
  const key = Symbol();
  // 这里的 this 是调用者
  context[key] = this;
  const result = context[key](...reset);
  // 删除副作用属性
  delete context[key];
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.apply(obj, [false, "catXXX"]); // xxx 25 false catXXX
foo.myApply(obj, [false, "catXXX"]); // xxx 25 false catXXX

console.log(Math.max.apply(Math, [1, 2, 3, 4, 1, 10])); // 10
console.log(Math.max.myApply(Math, [1, 2, 3, 4, 1, 10])); // 10

console.log([].shift.apply([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myApply([1, 2, 3, 4, 5, 6])); // 1
```

## bind

> [JavaScript 深入之 bind 的模拟实现](https://github.com/yygmind/blog/issues/23)

```javascript
Function.prototype.myBind = function (context = window) {
  let self = this;
  let NOOP = function () {};

  // 获取函数从第二个参数到最后一个参数
  const args = [].slice.call(arguments, 1);
  // const args = Array.prototype.slice.call(arguments, 1); 也可以使用这种写法
  let fBound = function () {
    // 这时候的 arguments 是 bind 返回的函数所传递的参数
    const bindArgs = [].slice.call(arguments);
    // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
    return self.apply(
      this instanceof NOOP ? this : context,
      args.concat(bindArgs)
    );
  };

  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  NOOP.prototype = this.prototype;
  fBound.prototype = new NOOP();
  return fBound;
};

// demo
let testFoo = {
  value: 1,
};

function bar(name: string, age: number) {
  this.habit = "shopping";
  console.log(this.value);
  console.log(name);
  console.log(age);
}

bar.prototype.friend = "xxx";

let bindFoo = bar.bind(testFoo, "xxx1");
let testObj = new bindFoo(18);

// undefined
// xxx1
// 18
console.log(testObj.habit); // shopping
console.log(testObj.friend); // xxx

let bindFoo2 = bar.myBind(testFoo, "xxx2");
let testObj2 = new bindFoo2(20);
// undefined
// xxx2
// 20
console.log(testObj2.habit); // shopping
console.log(testObj2.friend); // xxx
```

## debounce

在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

> [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

**简易版本**

```javascript
const debounce = function (fn, delay = 500) {
  let timer = null;

  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      return fn.apply(this, args);
    }, delay);
  };
};

// demo
document.getElementsByTagName("img")[0].addEventListener(
  "click",
  debounce(() => console.log("2222"))
);
```

**多功能版本**

```typescript
/**
 * 防抖
 * 事件在 n 后执行，如果 n 秒内别多次执行，则重新计时
 * 当使用 immediate 时候，
 * 此时注意一点，就是回调函数可能是有返回值的，
 * 所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，
 * 我们将 fn.apply(context, args) 的返回值赋给变量，
 * 最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。
 * @param fn 回调函数
 * @param delay 延迟时间
 * @param immediate 是否立即执行
 * @returns 返回毁掉函数执行的结果
 */
const debounce = (fn: Function, delay = 500, immediate = false) => {
  let timer: null | number = null;
  // let result: any = null;

  const debounced = function (...args: unknown[]) {
    if (timer) {
      clearTimeout(timer);
    }
    if (immediate) {
      // 如果已经执行了，则不再执行
      let callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);
      if (callNow) {
        fn.apply(this, args);
        // result = fn.apply(this, args);
      }
    } else {
      timer = setTimeout(() => {
        return fn.apply(this, args);
      }, delay);
    }
    // return result;
  };

  /**
   * 取消 debounce 函数
   */
  debounced.cancel = function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = null;
  };

  return debounced;
};
```

```typescript
// demo
const imgNode = document.getElementsByTagName("img")[0];
const btn = document.getElementsByTagName("button")[0];

function testFn2(event: EventTarget) {
  console.log("event :>> ", event);
}
const clickTestFn = debounce(testFn2, 5000, true);

imgNode.addEventListener("click", clickTestFn);
btn.addEventListener("click", () => clickTestFn.cancel());
```

## throttle

在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

**简易版本**

```javascript
const throttle = function (fn, delay = 500) {
  let flag = true;

  return function (...args) {
    if (!flag) return;
    flag = false;

    setTimeout(() => {
      fn.apply(this, args);
      flag = true;
    }, delay);
  };
};
```
