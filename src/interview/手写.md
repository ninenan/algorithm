# 手写实现

## new

1. 创建一个空对象
2. 为创建的空对象添加\_\_proto\_\_属性，并将其链接至构造函数的 prototype
3. 为创建的对象作为 this 的上下文
4. 如果函数没有返回对象，则返回 this

```javascript
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}
```

```javascript
// demo.js
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}

function Person(name, sex) {
  this.name = name;
  return {
    sex: sex,
    height: 178,
  };
}

let person1 = new Person("zhangsan", true);

console.log(person1.name); // undefined
console.log(person1.sex); // true
console.log(person1.height); // 178

let person2 = myNew(Person, "zhangsan", true);
console.log(person2.name); // undefined
console.log(person2.sex); // true
console.log(person2.height); // 178
```

## instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```javascript
function myInstanceof(paramL, paramR) {
  let L = paramL.__proto__;
  let R = paramR.prototype;

  while (true) {
    if (!L) {
      return false;
    }
    if (L === R) {
      return true;
    }
    L = L.__proto__;
  }
}

// demo
function Foo() {}

console.log(myInstanceof(Object, Object)); // true
console.log(myInstanceof(Function, Function)); // true
console.log(myInstanceof(Foo, Foo)); // false
```

## call

call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。
[Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
// 传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替
// context 不传就默认是 window 环境
Function.prototype.myCall = function (context = window, ...rest) {
  rest = rest ? rest : [];
  // 给 context 新增一个独一无二的属性防止覆盖原有的属性
  const key = Symbol();
  // 获取调用call的函数，用this可以获取
  context[key] = this;
  // 通过隐式绑定的方式调用函数
  const result = context[key](...rest);
  // 删除添加的属性
  delete context[key];
  // 返回函数调用的返回值
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.call(obj, false, "catXXX"); // xxx 25 false catXXX
foo.myCall(obj, false, "catXXX"); // xxx 25 false catXXX

console.log(Math.max.call(Math, 1, 2, 3, 4, 1, 10)); // 10
console.log(Math.max.myCall(Math, 1, 2, 3, 4, 1, 10)); // 10

console.log([].shift.call([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myCall([1, 2, 3, 4, 5, 6])); // 1
```

## apply

apply() 方法调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供的参数。

[Function.prototype.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
Function.prototype.myApply = function (context = window, ...reset: any[]) {
  reset = Array.isArray(reset[0]) ? reset[0] : [];
  // 给context新增一个独一无二的属性以免覆盖原有属性
  const key = Symbol();
  // 这里的 this 是调用者
  context[key] = this;
  const result = context[key](...reset);
  // 删除副作用属性
  delete context[key];
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.apply(obj, [false, "catXXX"]); // xxx 25 false catXXX
foo.myApply(obj, [false, "catXXX"]); // xxx 25 false catXXX

console.log(Math.max.apply(Math, [1, 2, 3, 4, 1, 10])); // 10
console.log(Math.max.myApply(Math, [1, 2, 3, 4, 1, 10])); // 10

console.log([].shift.apply([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myApply([1, 2, 3, 4, 5, 6])); // 1
```

## bind

bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

**一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。**

[Function.prototype.bind()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

> [JavaScript 深入之 bind 的模拟实现](https://github.com/yygmind/blog/issues/23)

```javascript
Function.prototype.myBind = function (context = window) {
  let self = this;
  let NOOP = function () {};

  // 获取函数从第二个参数到最后一个参数
  const args = [].slice.call(arguments, 1);
  // const args = Array.prototype.slice.call(arguments, 1); 也可以使用这种写法
  let fBound = function () {
    // 这时候的 arguments 是 bind 返回的函数所传递的参数
    const bindArgs = [].slice.call(arguments);
    // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
    return self.apply(
      this instanceof NOOP ? this : context,
      args.concat(bindArgs)
    );
  };

  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  NOOP.prototype = this.prototype;
  fBound.prototype = new NOOP();
  return fBound;
};

// demo
let testFoo = {
  value: 1,
};

function bar(name: string, age: number) {
  this.habit = "shopping";
  console.log(this.value);
  console.log(name);
  console.log(age);
}

bar.prototype.friend = "xxx";

let bindFoo = bar.bind(testFoo, "xxx1");
let testObj = new bindFoo(18);

// undefined
// xxx1
// 18
console.log(testObj.habit); // shopping
console.log(testObj.friend); // xxx

let bindFoo2 = bar.myBind(testFoo, "xxx2");
let testObj2 = new bindFoo2(20);
// undefined
// xxx2
// 20
console.log(testObj2.habit); // shopping
console.log(testObj2.friend); // xxx
```

## debounce

在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

> [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

**简易版本**

```javascript
const debounce = function (fn, delay = 500) {
  let timer = null;

  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      return fn.apply(this, args);
    }, delay);
  };
};

// demo
document.getElementsByTagName("img")[0].addEventListener(
  "click",
  debounce(() => console.log("2222"))
);
```

**多功能版本**

```typescript
/**
 * 防抖
 * 事件在 n 后执行，如果 n 秒内别多次执行，则重新计时
 * 当使用 immediate 时候，
 * 此时注意一点，就是回调函数可能是有返回值的，
 * 所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，
 * 我们将 fn.apply(context, args) 的返回值赋给变量，
 * 最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。
 * @param fn 回调函数
 * @param delay 延迟时间
 * @param immediate 是否立即执行
 * @returns 返回毁掉函数执行的结果
 */
const debounce = (fn: Function, delay = 500, immediate = false) => {
  let timer: null | number = null;
  // let result: any = null;

  const debounced = function (...args: unknown[]) {
    if (timer) {
      clearTimeout(timer);
    }
    if (immediate) {
      // 如果已经执行了，则不再执行
      let callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);
      if (callNow) {
        return fn.apply(this, args);
        // result = fn.apply(this, args);
      }
    } else {
      timer = setTimeout(() => {
        return fn.apply(this, args);
      }, delay);
    }
    // return result;
  };

  /**
   * 取消 debounce 函数
   */
  debounced.cancel = function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = null;
  };

  return debounced;
};
```

```typescript
// demo
const imgNode = document.getElementsByTagName("img")[0];
const btn = document.getElementsByTagName("button")[0];

function testFn2(event: EventTarget) {
  console.log("event :>> ", event);
}
const clickTestFn = debounce(testFn2, 5000, true);

imgNode.addEventListener("click", clickTestFn);
btn.addEventListener("click", () => clickTestFn.cancel());
```

## throttle

> [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)

在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

**简易版本**

```javascript
// 定时器版本
const throttle = function (fn, delay = 500) {
  let flag = true;

  return function (...args) {
    if (!flag) return;
    flag = false;

    setTimeout(() => {
      fn.apply(this, args);
      flag = true;
    }, delay);
  };
};

// 时间戳版本
const throttle = function (fn: Function, delay: number) {
  let previous = 0;

  return function (...reset: unknown[]) {
    const now = +new Date();
    if (now - previous > delay) {
      previous = now;
      fn.apply(this, reset);
    }
  };
};
```

**多功能版本**

```typescript
// 有头有尾
// 事件立即触发，停止触发之后还会再次触发一次
const throttle = function (fn: Function, delay: number) {
  let timeout: number | null = null,
    previous = 0,
    args: any = null,
    context: any = null;

  const later = function () {
    previous = +new Date();
    timeout = null;
    fn.apply(context, args);
  };

  const throttled = function () {
    const now = +new Date();
    // 下次触发 fn 的剩余事件
    const remaining = delay - (now - previous);
    context = this;
    args = arguments;
    // 如果没有剩余时间或者用户修改了系统时间
    if (remaining <= 0 || remaining > delay) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      fn.apply(context, args);
    } else if (!timeout) {
      timeout = setTimeout(later, delay);
    }
  };

  return throttled;
};
```

```typescript
// 有头无尾/无头有尾
// 事件立即触发，停止触发之后不会再次触发一次
// 事件不会立即触发，停止触发之后不会再次触发一次
interface IOptions {
  leading?: boolean; // 表示禁用第一次执行
  trailing?: boolean; // 表示禁用停止触发的回调
}

const throttle4 = function (
  fn: Function,
  delay: number,
  options: IOptions = { leading: true }
) {
  let timeout: number | null = null,
    context: any = null,
    previous: number = 0,
    args: any = null;

  const later = function () {
    previous = options.leading === false ? 0 : +new Date();
    timeout = null;
    fn.apply(context, args);
    if (!timeout) context = args = null;
  };
  const throttled = function () {
    const now = +new Date();
    if (!previous && options.leading === false) previous = now;
    const remaining = delay - (now - previous);
    context = this;
    args = arguments;
    // 如果没有剩余时间了或者用户修改了系统时间
    if (remaining <= 0 || remaining > delay) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      fn.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing === true) {
      timeout = setTimeout(later, delay);
    }
  };

  /**
   * 取消
   */
  throttled.cancel = function () {
    if (timeout) {
      clearTimeout(timeout);
    }
    previous = 0;
    timeout = null;
  };

  return throttled;
};
```

## 继承

### 原型链继承

```javascript
function SuperType() {
  this.property = true;
  this.colors = ["red", "white"];
}

SuperType.prototype.getSuperValue = function () {
  return this.property;
};

function SubType() {
  this.subProperty = false;
}

// 关键代码
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function () {
  return this.subProperty;
};

let instance1 = new SubType();
instance1.colors.push("blue");

console.log(instance1.property); // true
console.log(instance1.colors); // [ 'red', 'white', 'blue' ]
console.log(instance1.getSuperValue()); // true
console.log(instance1.getSubValue()); // fasle

let instance2 = new SubType();

console.log(instance1.property); // true
console.log(instance1.colors); // ['red', 'white', 'blue']
console.log(instance1.getSuperValue()); // true
console.log(instance1.getSubValue()); // fasle
```

**缺点**

1. 多个实例对**引用类型**的操作会被篡改。
2. 不能传递参数

### 借用构造函数继承

```javascript
function SuperType(name) {
  this.property = true;
  this.colors = ["red", "white"];
  this.name = name;
}

SuperType.prototype.getSuperValue = function () {
  return this.property;
};

function SubType() {
  // 继承自SuperType 因此SubType的每个实例都会将SuperType中的属性复制一份。
  SuperType.call(this, "name1");
}

SubType.prototype.getSubValue = function () {
  return this.subProperty;
};

let instance1 = new SubType();
instance1.colors.push("blue");
console.log(instance1.property); // true
console.log(instance1.colors); // [ 'red', 'white', 'blue' ]
console.log(instance1.getSuperValue()); // instance1.getSuperValue is not a function

let instance2 = new SubType();
console.log(instance2.property); // true
console.log(instance2.colors); // [ 'red', 'white' ]
```

1. 只能继承父类的实例属性和方法，不能继承**原型**属性/方法
2. 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 组合继承

```javascript
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "black"];
}

SuperType.prototype.getColors = function () {
  return this.colors;
};

function SubType(name) {
  // 继承实例属性/方法 第二次调用 Supertype()
  SuperType.call(this, name);
}

// 继承原型属性/方法 第一次调用 Supertype()
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;

let instance1 = new SubType("zhangsan");

console.log(instance1.name); // zhangsan
instance1.colors.push("white");
console.log(instance1.getColors()); // [ 'red', 'black', 'white' ]

let instance2 = new SubType("xiaoming");

console.log(instance2.name); // xiaoming
instance2.colors.push("blue");
console.log(instance2.getColors()); // [ 'red', 'black', 'blue' ]
```

**缺点**

1. 多占用内存，使用子类创建实例时，其原型中会存在两次相同的属性/方法。

### 原型式继承

```javascript
// 利用一个空对象，将某个对象直接赋值给空对象的构造上属的原型
// 其实就是 Object.create()
function myObject(param) {
  function F() {}
  F.prototype = param;
  return new F();
}

let person = {
  name: "zhangsan",
  friends: ["wwangwu", "lisi"],
};

let anotherPerson = myObject(person);
// let anotherPerson = Object.create(person) // 一样的作用

anotherPerson.name = "xiaoming";
anotherPerson.friends.push("xiaohong");

let yetAnotherPerson = myObject(person);
console.log(yetAnotherPerson.friends); // [ 'wwangwu', 'lisi', 'xiaohong' ]
```

**缺点**

1. 无法传递参数
2. 多个实例对引用类型的操作会被篡改。

### 寄生式继承

创建一个实例继承的函数，以某种方式增强对象，然后返回这个对象。

```javascript
function myObject(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
function createPeron(obj) {
  let clone = myObject(obj);
  clone.sayHi = function () {
    console.log("Hi");
  };
  return clone;
}

let person = {
  name: "zhangsan",
  friends: ["xiaoming"],
};

let anotherPerson = createPeron(person);
anotherPerson.sayHi(); // Hi
```

**缺点**

1. 无法传递参数
2. 多个实例对应用类型的操作会被篡改

### 寄生组合式继承 ✨✨✨✨✨✨

```javascript
function inheritPrototype(SubType, Supertype) {
  // 创建对象，父类对象的副本
  let prototype = Object.create(Supertype.prototype);
  // 增强对象，定义因为重写原型丢失的 constructor 属性
  prototype.constructor = SubType;
  // 指定对象，将创建的对象赋值给子类的原型
  SubType.prototype = prototype;
}
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "black"];
}

SuperType.prototype.getColors = function () {
  return this.colors;
};

// 关键代码
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}

// 关键代码
// 将父类原型指向子类
inheritPrototype(SubType, SuperType);

SubType.prototype.getAge = function () {
  return this.age;
};

let instance1 = new SubType("zhangsan", 18);
console.log(instance1.name); // zhangsan
console.log(instance1.age); // 18
instance1.colors.push("white");
console.log(instance1.getColors()); // [ 'red', 'black', 'white' ]

let instance2 = new SubType("xiaoming", 25);

console.log(instance2.name); // xiaoming
console.log(instance2.age); // 25
instance2.colors.push("blue");
console.log(instance2.getColors()); // [ 'red', 'black', 'blue' ]
```

这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，
因此可以说这个例子的效率更高。

**寄生式组合继承**可以算是引用类型继承的最佳模式。
