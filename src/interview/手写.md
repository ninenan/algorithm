# 手写实现

## new

1. 创建一个空对象
2. 为创建的空对象添加\_\_proto\_\_属性，并将其链接至构造函数的 prototype
3. 为创建的对象作为 this 的上下文
4. 如果函数没有返回对象，则返回 this

```javascript
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}
```

```javascript
// demo.js
function myNew() {
  // 创建一个空对象
  let obj = new Object();
  // 获取构造函数，去除 arguments 的第一个参数
  let Constructor = [].shift.call(arguments);
  // 将空对象的 __proto__ 指向 构造函数的 prototype
  obj.__proto__ = Constructor.prototype;
  // 绑定 this，obj 可以访问构造函数中的属性
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}

function Person(name, sex) {
  this.name = name;
  return {
    sex: sex,
    height: 178,
  };
}

let person1 = new Person("zhangsan", true);

console.log(person1.name); // undefined
console.log(person1.sex); // true
console.log(person1.height); // 178

let person2 = myNew(Person, "zhangsan", true);
console.log(person2.name); // undefined
console.log(person2.sex); // true
console.log(person2.height); // 178
```

## instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```javascript
function myInstanceof(paramL, paramR) {
  let L = paramL.__proto__;
  let R = paramR.prototype;

  while (true) {
    if (!L) {
      return false;
    }
    if (L === R) {
      return true;
    }
    L = L.__proto__;
  }
}

// demo
function Foo() {}

console.log(myInstanceof(Object, Object)); // true
console.log(myInstanceof(Function, Function)); // true
console.log(myInstanceof(Foo, Foo)); // false
```

## call

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
// 传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替
// context 不传就默认是 window 环境
Function.prototype.myCall = function (context = window, ...rest) {
  rest = rest ? rest : [];
  // 给 context 新增一个独一无二的属性防止覆盖原有的属性
  const key = Symbol();
  // 获取调用call的函数，用this可以获取
  context[key] = this;
  // 通过隐式绑定的方式调用函数
  const result = context[key](...rest);
  // 删除添加的属性
  delete context[key];
  // 返回函数调用的返回值
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.call(obj, false, "catXXX"); // xxx 25 false catXXX
foo.myCall(obj, false, "catXXX"); // xxx 25 false catXXX

console.log(Math.max.call(Math, 1, 2, 3, 4, 1, 10)); // 10
console.log(Math.max.myCall(Math, 1, 2, 3, 4, 1, 10)); // 10

console.log([].shift.call([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myCall([1, 2, 3, 4, 5, 6])); // 1
```

## apply

> [JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

```javascript
Function.prototype.myApply = function (context = window, ...reset: any[]) {
  reset = reset[0] ? reset[0] : [];
  // 给context新增一个独一无二的属性以免覆盖原有属性
  const key = Symbol();
  // 这里的 this 是调用者
  context[key] = this;
  const result = context[key](...reset);
  // 删除副作用属性
  delete context[key];
  return result;
};

// demo
function foo(sex, catName) {
  console.log(this.name);
  console.log(this.age);
  console.log(sex);
  console.log(catName);
}
const obj = {
  name: "xxx",
  age: 25,
};

foo.apply(obj, [false, "catXXX"]); // xxx 25 false catXXX
foo.myApply(obj, [false, "catXXX"]); // xxx 25 false catXXX

console.log(Math.max.apply(Math, [1, 2, 3, 4, 1, 10])); // 10
console.log(Math.max.myApply(Math, [1, 2, 3, 4, 1, 10])); // 10

console.log([].shift.apply([1, 2, 3, 4, 5, 6])); // 1
console.log([].shift.myApply([1, 2, 3, 4, 5, 6])); // 1
```

## bind

> [JavaScript 深入之 bind 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12)

```javascript
Function.prototype.myBind = function (context = window) {
  let self = this;
  let NOOP = function () {};

  // 获取函数从第二个参数到最后一个参数
  const args = [].slice.call(arguments, 1);
  // const args = Array.prototype.slice.call(arguments, 1); 也可以使用这种写法
  let fBound = function () {
    // 这时候的 arguments 是 bind 返回的函数所传递的参数
    const bindArgs = [].slice.call(arguments);
    // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
    return self.apply(
      this instanceof NOOP ? this : context,
      args.concat(bindArgs)
    );
  };

  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  NOOP.prototype = this.prototype;
  fBound.prototype = new NOOP();
  return fBound;
};

// demo
let testFoo = {
  value: 1,
};

function bar(name: string, age: number) {
  this.habit = "shopping";
  console.log(this.value);
  console.log(name);
  console.log(age);
}

bar.prototype.friend = "xxx";

let bindFoo = bar.bind(testFoo, "xxx1");
let testObj = new bindFoo(18);

// undefined
// xxx1
// 18
console.log(testObj.habit); // shopping
console.log(testObj.friend); // xxx

let bindFoo2 = bar.myBind(testFoo, "xxx2");
let testObj2 = new bindFoo2(20);
// undefined
// xxx2
// 20
console.log(testObj2.habit); // shopping
console.log(testObj2.friend); // xxx
```
